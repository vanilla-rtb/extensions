{{ $entities := .CachedEntities }}
{{ $entities_length := len $entities }}
{{ $build_type := .BuildType }}
{{ $bidder_name := .BidderName }}

#include <vector>
#include <random>
#include <boost/log/trivial.hpp>
#include <boost/program_options.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/case_conv.hpp>

#include "rtb/core/core.hpp"
#include "rtb/exchange/exchange_handler.hpp"
#include "rtb/exchange/exchange_server.hpp"
#include "rtb/DSL/generic_dsl.hpp"
//#include "rtb/DSL/any_mapper.hpp"
#include "rtb/DSL/rapid_mapper.hpp"
#include "rtb/config/config.hpp"
#include "rtb/core/tagged_tuple.hpp"
#include "rtb/core/bidder.hpp"
#include "rtb/core/ad_selector.hpp"
#include "rtb/datacache/entity_cache.hpp"
#include "rtb/datacache/memory_types.hpp"
#include "rtb/datacache/generic_bidder_cache_loader.hpp"
#include "CRUD/handlers/crud_dispatcher.hpp"
#include "examples/matchers/ad.hpp"
#include "examples/campaign/campaign_cache.hpp"

//create go.template for this part the matcher files are generated by 
//go run  bidder_generator.go --output-dir nodejs  --input-template templates/bidder.tmpl -g bidder 
{{range $entity := $entities -}}
#include "{{ $entity | GetReflectionTypeName | ToLower }}.hpp"
{{end}}

namespace {{ .BidderName }} {
struct config_data {
{{range $entity := $entities -}}
{{$entity_lcase := $entity | GetReflectionTypeName | ToLower -}}

std::string {{$entity_lcase}}_source;
std::string {{$entity_lcase}}_ipc_name;
{{end -}}
std::string log_file_name;
std::string ads_source;
std::string ads_ipc_name;
std::string campaign_budget_source;
std::string ipc_name;
int timeout;
unsigned int concurrency;
short port;
std::string host;
std::string root;
short num_of_bidders;
};
}

extern void init_framework_logging(const std::string &) ;

using namespace vanilla;

{{if eq $build_type "LIB" -}}
int __main__(int argc, char *argv[]) {
{{else -}}
int main(int argc, char *argv[]) {
{{end -}}
    using namespace std::placeholders;
    using namespace vanilla::exchange;
    using namespace std::chrono_literals;
    using restful_dispatcher_t =  http::crud::crud_dispatcher<http::server::request, http::server::reply> ;
    using DSLT = DSL::GenericDSL<std::string, DSL::rapid_mapper> ;
    using BidRequest = DSLT::deserialized_type;
    using BidResponse = DSLT::serialized_type;
    using BidderConfig = vanilla::config::config<{{ .BidderName }}::config_data>;
    using CacheLoader  =  vanilla::GenericBidderCacheLoader<
    {{- range $entity := $entities -}}
    {{$entity | GetReflectionTypeName}}Entity<BidderConfig>,
    {{- end -}}
    AdDataEntity<BidderConfig>, CampaignCache<BidderConfig>>;
    using Selector = vanilla::ad_selector<vanilla::BudgetManager, Ad>;

    BidderConfig config([]({{ $bidder_name }}::config_data &d, boost::program_options::options_description &desc){
        desc.add_options()
////////////////////// GENERATE BEGIN ///////////////////////
            {{range $entity := $entities -}}
            {{- $entity_lcase := $entity | GetReflectionTypeName | ToLower -}}
            ("{{ $bidder_name }}.{{ $entity_lcase }}_source", boost::program_options::value<std::string>(&d.{{ $entity_lcase }}_source)->default_value("data/{{ $entity_lcase }}"), "domain_source file name")
            ("{{ $bidder_name }}.{{ $entity_lcase }}_ipc_name", boost::program_options::value<std::string>(&d.{{ $entity_lcase }}_ipc_name)->default_value("vanilla-{{ $entity_lcase }}-ipc"), " {{ $entity_lcase }} ipc name")
            {{ end }}
////////////////////// GENERATE END ////////////////////////
            ("{{ $bidder_name }}.ads_source", boost::program_options::value<std::string>(&d.ads_source)->default_value("data/ico_ads"), "ico ads_source file name")
            ("{{ $bidder_name }}.ads_ipc_name", boost::program_options::value<std::string>(&d.ads_ipc_name)->default_value("vanilla-ads-ipc"), "ads ipc name")
            ("campaign-manager.ipc_name", boost::program_options::value<std::string>(&d.ipc_name),"campaign_budget IPC name")
            ("campaign-manager.budget_source", boost::program_options::value<std::string>(&d.campaign_budget_source)->default_value("data/campaign_budget"),"campaign_budget source file name")
            ("{{ $bidder_name }}.log", boost::program_options::value<std::string>(&d.log_file_name), "bidder log file name log")
            ("{{ $bidder_name }}.port", boost::program_options::value<short>(&d.port)->required(), "bidder port")
            ("{{ $bidder_name }}.host", boost::program_options::value<std::string>(&d.host)->default_value("0.0.0.0"), "bidder host")
            ("{{ $bidder_name }}.root", boost::program_options::value<std::string>(&d.root)->default_value("."), "bidder root")
            ("{{ $bidder_name }}.timeout", boost::program_options::value<int>(&d.timeout), "bidder timeout")
            ("{{ $bidder_name }}.concurrency", boost::program_options::value<unsigned int>(&d.concurrency)->default_value(0), "bidder concurrency, if 0 is set std::thread::hardware_concurrency()")
        ;
    });
    
    try {
        config.parse(argc, argv);
    }
    catch(std::exception const& e) {
        LOG(error) << e.what();
        return 0;
    }
    LOG(debug) << config;
    init_framework_logging(config.data().log_file_name);

    CacheLoader cacheLoader(config);
    try {
        cacheLoader.load(); // Not needed if data cache loader is in work
    }
    catch(std::exception const& e) {
        LOG(error) << e.what();
        return 0;
    }
    
    using bid_handler_type = exchange_handler<DSLT>;

    bid_handler_type bid_handler(std::chrono::milliseconds(config.data().timeout));

    //Return from each lambda becomes input for next lambda in the tuple of functions
     {{range $i,$entity := $entities -}} 
     {{$entity_var :=  $entity | GetReflectionTypeName | ToLower -}}
     {{$entity_collection := printf "%s%s" $entity_var "s" -}}
     {{$output_fields := $entity | GetCacheFields | GetFieldValues -}}
     {{$output_field := index $output_fields 0 -}}
     {{if NotLast $i $entities -}}
    auto retrieve_{{$entity_var}}_f = [&cacheLoader]( auto && key, auto&& ...)  {
        {{$entity | GetReflectionTypeName}}  {{$entity_var}} ;
        auto &value =  {{$entity_var}}.{{$output_field.FieldName}}; //TODO support for mutiple tupple
        if (!cacheLoader.retrieve( {{$entity_var}},{{if eq $i 0}}key{{else}}*key{{end}})) {
            return boost::optional<decltype(value)>();
        }
        return boost::optional<decltype(value)>(value);
    };
    {{ else -}}
    auto retrieve_{{$entity_var}}_f = [&cacheLoader]( auto && key, auto&& ...)  {
        std::vector<{{$entity | GetReflectionTypeName}}>  {{$entity_collection}} ;
        if (!cacheLoader.retrieve({{$entity_collection}},*key)) {
            return boost::optional<decltype({{$entity_collection}})>();
        }
        return boost::optional<decltype( {{$entity_collection}} )>( {{$entity_collection}} );
    };
    using Campaign = {{$entity | GetReflectionTypeName}};
    {{end -}}
    {{end -}}
    vanilla::core::Banker<BudgetManager> banker;
    auto retrieve_campaign_ads_f = [&](boost::optional<std::vector<Campaign>> campaigns, auto && req, auto && imp)  {
        std::vector<Ad> retrieved_cached_ads;
        for (auto &campaign : *campaigns) {
            if (!cacheLoader.retrieve(retrieved_cached_ads, campaign.campaign_id, imp.banner.get().w, imp.banner.get().h)) {
                continue;
            }
            auto budget_bid = banker.authorize(cacheLoader.get<CampaignCache<BidderConfig>>(), campaign.campaign_id);
            std::transform(std::begin(retrieved_cached_ads),
                           std::end(retrieved_cached_ads),
                           std::begin(retrieved_cached_ads), [budget_bid](Ad & ad){
                        ad.auth_bid_micros = std::min(budget_bid, ad.max_bid_micros);
                        return ad;
                    });
        }
        return retrieved_cached_ads;
    };

    bid_handler    
        .logger([](const std::string &data) {
            //LOG(debug) << "bid request=" << data ;
        })
        .error_logger([](const std::string &data) {
            LOG(debug) << "bid request error " << data ;
        })
        .auction_async([&](const BidRequest &request) {
            thread_local vanilla::Bidder<DSLT, Selector> bidder(std::move(Selector()));
            return bidder.bid(request,
                              //chained matchers
                              request.site.get().ref,
                              {{range $entity := $entities -}}
                              {{$entity_var :=  $entity | GetReflectionTypeName | ToLower -}}
                              retrieve_{{$entity_var}}_f,
                              {{ end -}}
                              retrieve_campaign_ads_f
            );
        });
    
    connection_endpoint ep {std::make_tuple(config.data().host, boost::lexical_cast<std::string>(config.data().port), config.data().root)};

    //initialize and setup CRUD dispatcher
    restful_dispatcher_t dispatcher(ep.root);
    dispatcher.crud_match(boost::regex("/ico_bid/(\\d+)"))
            .post([&](http::server::reply & r, const http::crud::crud_match<boost::cmatch> & match) {
                bid_handler.handle_post(r, match);
            });

    LOG(debug) << "concurrency " << config.data().concurrency;
    exchange_server<restful_dispatcher_t> server{ep,dispatcher} ;
    server.set_concurrency(config.data().concurrency).run() ;
}


